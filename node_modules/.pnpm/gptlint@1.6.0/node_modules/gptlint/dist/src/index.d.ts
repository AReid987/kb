import { ChatModel } from '@dexaai/dexter';
import { Command } from 'cleye';
import { TaskAPI, TaskInnerAPI } from 'tasuku';
import { Simplify, SetRequired, SimplifyDeep, MergeDeep, SetOptional } from 'type-fest';
import { z } from 'zod';
import { FailedAttemptError } from 'p-retry';
import { Options } from 'globby';
export { default as slugify } from '@sindresorhus/slugify';
export { default as dedupe } from 'array-uniq';
export { default as assert } from 'tiny-invariant';

declare const LinterConfigRuleSettingSchema: z.ZodEnum<["off", "warn", "error"]>;
type LinterConfigRuleSetting = z.infer<typeof LinterConfigRuleSettingSchema>;
declare const LinterConfigRuleSettingsSchema: z.ZodRecord<z.ZodString, z.ZodEnum<["off", "warn", "error"]>>;
type LinterConfigRuleSettings = z.infer<typeof LinterConfigRuleSettingsSchema>;
declare const defaultCacheDir: string;
declare const LLMOptionsSchema: z.ZodObject<{
    model: z.ZodOptional<z.ZodString>;
    weakModel: z.ZodNullable<z.ZodOptional<z.ZodString>>;
    temperature: z.ZodOptional<z.ZodNumber>;
    modelSupportsJsonResponseFormat: z.ZodOptional<z.ZodBoolean>;
    apiKey: z.ZodOptional<z.ZodString>;
    apiOrganizationId: z.ZodOptional<z.ZodString>;
    apiBaseUrl: z.ZodOptional<z.ZodString>;
    kyOptions: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
}, "strict", z.ZodTypeAny, {
    apiKey?: string | undefined;
    apiOrganizationId?: string | undefined;
    apiBaseUrl?: string | undefined;
    model?: string | undefined;
    weakModel?: string | null | undefined;
    temperature?: number | undefined;
    modelSupportsJsonResponseFormat?: boolean | undefined;
    kyOptions?: Record<string, any> | undefined;
}, {
    apiKey?: string | undefined;
    apiOrganizationId?: string | undefined;
    apiBaseUrl?: string | undefined;
    model?: string | undefined;
    weakModel?: string | null | undefined;
    temperature?: number | undefined;
    modelSupportsJsonResponseFormat?: boolean | undefined;
    kyOptions?: Record<string, any> | undefined;
}>;
type LLMOptions = z.infer<typeof LLMOptionsSchema>;
declare const LinterOptionsSchema: z.ZodObject<{
    noInlineConfig: z.ZodOptional<z.ZodBoolean>;
    earlyExit: z.ZodOptional<z.ZodBoolean>;
    debug: z.ZodOptional<z.ZodBoolean>;
    printConfig: z.ZodOptional<z.ZodBoolean>;
    debugModel: z.ZodOptional<z.ZodBoolean>;
    debugGrit: z.ZodOptional<z.ZodBoolean>;
    debugStats: z.ZodOptional<z.ZodBoolean>;
    noCache: z.ZodOptional<z.ZodBoolean>;
    noGrit: z.ZodOptional<z.ZodBoolean>;
    disabled: z.ZodOptional<z.ZodBoolean>;
    dryRun: z.ZodOptional<z.ZodBoolean>;
    cacheDir: z.ZodOptional<z.ZodString>;
    concurrency: z.ZodOptional<z.ZodNumber>;
}, "strict", z.ZodTypeAny, {
    noInlineConfig?: boolean | undefined;
    noCache?: boolean | undefined;
    noGrit?: boolean | undefined;
    cacheDir?: string | undefined;
    concurrency?: number | undefined;
    debug?: boolean | undefined;
    dryRun?: boolean | undefined;
    printConfig?: boolean | undefined;
    debugModel?: boolean | undefined;
    debugGrit?: boolean | undefined;
    earlyExit?: boolean | undefined;
    debugStats?: boolean | undefined;
    disabled?: boolean | undefined;
}, {
    noInlineConfig?: boolean | undefined;
    noCache?: boolean | undefined;
    noGrit?: boolean | undefined;
    cacheDir?: string | undefined;
    concurrency?: number | undefined;
    debug?: boolean | undefined;
    dryRun?: boolean | undefined;
    printConfig?: boolean | undefined;
    debugModel?: boolean | undefined;
    debugGrit?: boolean | undefined;
    earlyExit?: boolean | undefined;
    debugStats?: boolean | undefined;
    disabled?: boolean | undefined;
}>;
type LinterOptions = z.infer<typeof LinterOptionsSchema>;
declare const LinterConfigOverrideSchema: z.ZodObject<{
    include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    rules: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodEnum<["off", "warn", "error"]>>>;
}, "strict", z.ZodTypeAny, {
    rules?: Record<string, "error" | "warn" | "off"> | undefined;
    include?: string[] | undefined;
    exclude?: string[] | undefined;
}, {
    rules?: Record<string, "error" | "warn" | "off"> | undefined;
    include?: string[] | undefined;
    exclude?: string[] | undefined;
}>;
type LinterConfigOverride = z.infer<typeof LinterConfigOverrideSchema>;
declare const LinterConfigOverridesSchema: z.ZodArray<z.ZodObject<{
    include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    rules: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodEnum<["off", "warn", "error"]>>>;
}, "strict", z.ZodTypeAny, {
    rules?: Record<string, "error" | "warn" | "off"> | undefined;
    include?: string[] | undefined;
    exclude?: string[] | undefined;
}, {
    rules?: Record<string, "error" | "warn" | "off"> | undefined;
    include?: string[] | undefined;
    exclude?: string[] | undefined;
}>, "many">;
type LinterConfigOverrides = z.infer<typeof LinterConfigOverridesSchema>;
declare const LinterConfigSchema: z.ZodObject<{
    files: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    ignores: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    ruleFiles: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    ruleDefinitions: z.ZodOptional<z.ZodArray<z.ZodObject<{
        name: z.ZodEffects<z.ZodString, string, string>;
        title: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        fixable: z.ZodOptional<z.ZodBoolean>;
        cacheable: z.ZodOptional<z.ZodBoolean>;
        level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
        scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
        languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        model: z.ZodOptional<z.ZodString>;
        include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        gritql: z.ZodOptional<z.ZodString>;
        gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
        preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        source: z.ZodOptional<z.ZodString>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        name: z.ZodEffects<z.ZodString, string, string>;
        title: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        fixable: z.ZodOptional<z.ZodBoolean>;
        cacheable: z.ZodOptional<z.ZodBoolean>;
        level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
        scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
        languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        model: z.ZodOptional<z.ZodString>;
        include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        gritql: z.ZodOptional<z.ZodString>;
        gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
        preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        source: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        name: z.ZodEffects<z.ZodString, string, string>;
        title: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        fixable: z.ZodOptional<z.ZodBoolean>;
        cacheable: z.ZodOptional<z.ZodBoolean>;
        level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
        scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
        languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        model: z.ZodOptional<z.ZodString>;
        include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        gritql: z.ZodOptional<z.ZodString>;
        gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
        preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        source: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">>, "many">>;
    rules: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodEnum<["off", "warn", "error"]>>>;
    linterOptions: z.ZodOptional<z.ZodObject<{
        noInlineConfig: z.ZodOptional<z.ZodBoolean>;
        earlyExit: z.ZodOptional<z.ZodBoolean>;
        debug: z.ZodOptional<z.ZodBoolean>;
        printConfig: z.ZodOptional<z.ZodBoolean>;
        debugModel: z.ZodOptional<z.ZodBoolean>;
        debugGrit: z.ZodOptional<z.ZodBoolean>;
        debugStats: z.ZodOptional<z.ZodBoolean>;
        noCache: z.ZodOptional<z.ZodBoolean>;
        noGrit: z.ZodOptional<z.ZodBoolean>;
        disabled: z.ZodOptional<z.ZodBoolean>;
        dryRun: z.ZodOptional<z.ZodBoolean>;
        cacheDir: z.ZodOptional<z.ZodString>;
        concurrency: z.ZodOptional<z.ZodNumber>;
    }, "strict", z.ZodTypeAny, {
        noInlineConfig?: boolean | undefined;
        noCache?: boolean | undefined;
        noGrit?: boolean | undefined;
        cacheDir?: string | undefined;
        concurrency?: number | undefined;
        debug?: boolean | undefined;
        dryRun?: boolean | undefined;
        printConfig?: boolean | undefined;
        debugModel?: boolean | undefined;
        debugGrit?: boolean | undefined;
        earlyExit?: boolean | undefined;
        debugStats?: boolean | undefined;
        disabled?: boolean | undefined;
    }, {
        noInlineConfig?: boolean | undefined;
        noCache?: boolean | undefined;
        noGrit?: boolean | undefined;
        cacheDir?: string | undefined;
        concurrency?: number | undefined;
        debug?: boolean | undefined;
        dryRun?: boolean | undefined;
        printConfig?: boolean | undefined;
        debugModel?: boolean | undefined;
        debugGrit?: boolean | undefined;
        earlyExit?: boolean | undefined;
        debugStats?: boolean | undefined;
        disabled?: boolean | undefined;
    }>>;
    llmOptions: z.ZodOptional<z.ZodObject<{
        model: z.ZodOptional<z.ZodString>;
        weakModel: z.ZodNullable<z.ZodOptional<z.ZodString>>;
        temperature: z.ZodOptional<z.ZodNumber>;
        modelSupportsJsonResponseFormat: z.ZodOptional<z.ZodBoolean>;
        apiKey: z.ZodOptional<z.ZodString>;
        apiOrganizationId: z.ZodOptional<z.ZodString>;
        apiBaseUrl: z.ZodOptional<z.ZodString>;
        kyOptions: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    }, "strict", z.ZodTypeAny, {
        apiKey?: string | undefined;
        apiOrganizationId?: string | undefined;
        apiBaseUrl?: string | undefined;
        model?: string | undefined;
        weakModel?: string | null | undefined;
        temperature?: number | undefined;
        modelSupportsJsonResponseFormat?: boolean | undefined;
        kyOptions?: Record<string, any> | undefined;
    }, {
        apiKey?: string | undefined;
        apiOrganizationId?: string | undefined;
        apiBaseUrl?: string | undefined;
        model?: string | undefined;
        weakModel?: string | null | undefined;
        temperature?: number | undefined;
        modelSupportsJsonResponseFormat?: boolean | undefined;
        kyOptions?: Record<string, any> | undefined;
    }>>;
    overrides: z.ZodOptional<z.ZodArray<z.ZodObject<{
        include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        rules: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodEnum<["off", "warn", "error"]>>>;
    }, "strict", z.ZodTypeAny, {
        rules?: Record<string, "error" | "warn" | "off"> | undefined;
        include?: string[] | undefined;
        exclude?: string[] | undefined;
    }, {
        rules?: Record<string, "error" | "warn" | "off"> | undefined;
        include?: string[] | undefined;
        exclude?: string[] | undefined;
    }>, "many">>;
}, "strict", z.ZodTypeAny, {
    rules?: Record<string, "error" | "warn" | "off"> | undefined;
    llmOptions?: {
        apiKey?: string | undefined;
        apiOrganizationId?: string | undefined;
        apiBaseUrl?: string | undefined;
        model?: string | undefined;
        weakModel?: string | null | undefined;
        temperature?: number | undefined;
        modelSupportsJsonResponseFormat?: boolean | undefined;
        kyOptions?: Record<string, any> | undefined;
    } | undefined;
    linterOptions?: {
        noInlineConfig?: boolean | undefined;
        noCache?: boolean | undefined;
        noGrit?: boolean | undefined;
        cacheDir?: string | undefined;
        concurrency?: number | undefined;
        debug?: boolean | undefined;
        dryRun?: boolean | undefined;
        printConfig?: boolean | undefined;
        debugModel?: boolean | undefined;
        debugGrit?: boolean | undefined;
        earlyExit?: boolean | undefined;
        debugStats?: boolean | undefined;
        disabled?: boolean | undefined;
    } | undefined;
    files?: string[] | undefined;
    ignores?: string[] | undefined;
    ruleFiles?: string[] | undefined;
    ruleDefinitions?: z.objectOutputType<{
        name: z.ZodEffects<z.ZodString, string, string>;
        title: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        fixable: z.ZodOptional<z.ZodBoolean>;
        cacheable: z.ZodOptional<z.ZodBoolean>;
        level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
        scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
        languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        model: z.ZodOptional<z.ZodString>;
        include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        gritql: z.ZodOptional<z.ZodString>;
        gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
        preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        source: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">[] | undefined;
    overrides?: {
        rules?: Record<string, "error" | "warn" | "off"> | undefined;
        include?: string[] | undefined;
        exclude?: string[] | undefined;
    }[] | undefined;
}, {
    rules?: Record<string, "error" | "warn" | "off"> | undefined;
    llmOptions?: {
        apiKey?: string | undefined;
        apiOrganizationId?: string | undefined;
        apiBaseUrl?: string | undefined;
        model?: string | undefined;
        weakModel?: string | null | undefined;
        temperature?: number | undefined;
        modelSupportsJsonResponseFormat?: boolean | undefined;
        kyOptions?: Record<string, any> | undefined;
    } | undefined;
    linterOptions?: {
        noInlineConfig?: boolean | undefined;
        noCache?: boolean | undefined;
        noGrit?: boolean | undefined;
        cacheDir?: string | undefined;
        concurrency?: number | undefined;
        debug?: boolean | undefined;
        dryRun?: boolean | undefined;
        printConfig?: boolean | undefined;
        debugModel?: boolean | undefined;
        debugGrit?: boolean | undefined;
        earlyExit?: boolean | undefined;
        debugStats?: boolean | undefined;
        disabled?: boolean | undefined;
    } | undefined;
    files?: string[] | undefined;
    ignores?: string[] | undefined;
    ruleFiles?: string[] | undefined;
    ruleDefinitions?: z.objectInputType<{
        name: z.ZodEffects<z.ZodString, string, string>;
        title: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
            code: z.ZodString;
            language: z.ZodOptional<z.ZodString>;
        }, "strict", z.ZodTypeAny, {
            code: string;
            language?: string | undefined;
        }, {
            code: string;
            language?: string | undefined;
        }>, "many">>;
        fixable: z.ZodOptional<z.ZodBoolean>;
        cacheable: z.ZodOptional<z.ZodBoolean>;
        level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
        scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
        languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        model: z.ZodOptional<z.ZodString>;
        include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        gritql: z.ZodOptional<z.ZodString>;
        gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
        preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
        source: z.ZodOptional<z.ZodString>;
    }, z.ZodTypeAny, "passthrough">[] | undefined;
    overrides?: {
        rules?: Record<string, "error" | "warn" | "off"> | undefined;
        include?: string[] | undefined;
        exclude?: string[] | undefined;
    }[] | undefined;
}>;
type LinterConfig = z.infer<typeof LinterConfigSchema>;
type GPTLintConfig = LinterConfig[];
type ResolvedLinterOptions = Simplify<SetRequired<LinterOptions, keyof LinterOptions>>;
type ResolvedLLMOptions = Simplify<SetRequired<LLMOptions, 'model'>>;
type FullyResolvedLinterConfig = Simplify<Omit<SetRequired<LinterConfig, keyof LinterConfig>, 'linterOptions' | 'llmOptions'> & {
    linterOptions: ResolvedLinterOptions;
    llmOptions: ResolvedLLMOptions;
}>;
declare const defaultLinterOptions: Readonly<LinterOptions>;
declare const defaultLLMOptions: Readonly<LLMOptions>;
declare const defaultLinterConfig: Readonly<SetRequired<LinterConfig, 'linterOptions' | 'llmOptions'>>;
declare function parseLinterConfig(config: Partial<LinterConfig>): LinterConfig;
declare function isValidModel(model?: string | null): model is NonNullable<string>;
/** Union two configs together, with the second one taking precedence */
declare function mergeLinterConfigs<ConfigTypeA extends LinterConfig = LinterConfig, ConfigTypeB extends LinterConfig = LinterConfig>(configA: ConfigTypeA, configB: ConfigTypeB): SimplifyDeep<MergeDeep<ConfigTypeA, ConfigTypeB>>;
/**
 * Union two configs together, with the second one taking precedence, but
 * allow certain fields of the second config to override the first instead of
 * joining them together.
 *
 * This is used to allow CLI config values to completely override other configs.
 */
declare function mergeLinterConfigsOverride<ConfigTypeA extends LinterConfig = LinterConfig, ConfigTypeB extends LinterConfig = LinterConfig>(configA: ConfigTypeA, configB: ConfigTypeB): SimplifyDeep<MergeDeep<ConfigTypeA, ConfigTypeB>>;
declare function mergeLinterConfigRuleSettings(rulesA?: LinterConfigRuleSettings, rulesB?: LinterConfigRuleSettings): LinterConfigRuleSettings;
declare function resolveLinterConfig(config: Partial<LinterConfig>): FullyResolvedLinterConfig;
declare class ResolvedLinterConfig implements Pick<FullyResolvedLinterConfig, 'files' | 'ignores' | 'ruleFiles' | 'ruleDefinitions' | 'rules' | 'linterOptions' | 'llmOptions'> {
    readonly config: FullyResolvedLinterConfig;
    readonly ruleSettingsFileCache: Map<string, Record<string, "error" | "warn" | "off">>;
    constructor({ configs, cliConfigOverride }: {
        configs: LinterConfig[];
        cliConfigOverride: LinterConfig;
    });
    get files(): string[];
    get ignores(): string[];
    get ruleFiles(): string[];
    get rules(): LinterConfigRuleSettings;
    get ruleDefinitions(): RuleDefinition[];
    get linterOptions(): ResolvedLinterOptions;
    get llmOptions(): ResolvedLLMOptions;
    getRuleSettingsForFile(file: SourceFile): LinterConfigRuleSettings;
    getSanitizedDebugConfig(): Omit<{
        rules?: Record<string, "error" | "warn" | "off"> | undefined;
        llmOptions?: {
            apiKey?: string | undefined;
            apiOrganizationId?: string | undefined;
            apiBaseUrl?: string | undefined;
            model?: string | undefined;
            weakModel?: string | null | undefined;
            temperature?: number | undefined;
            modelSupportsJsonResponseFormat?: boolean | undefined;
            kyOptions?: Record<string, any> | undefined;
        } | undefined;
        linterOptions?: {
            noInlineConfig?: boolean | undefined;
            noCache?: boolean | undefined;
            noGrit?: boolean | undefined;
            cacheDir?: string | undefined;
            concurrency?: number | undefined;
            debug?: boolean | undefined;
            dryRun?: boolean | undefined;
            printConfig?: boolean | undefined;
            debugModel?: boolean | undefined;
            debugGrit?: boolean | undefined;
            earlyExit?: boolean | undefined;
            debugStats?: boolean | undefined;
            disabled?: boolean | undefined;
        } | undefined;
        files?: string[] | undefined;
        ignores?: string[] | undefined;
        ruleFiles?: string[] | undefined;
        ruleDefinitions?: z.objectOutputType<{
            name: z.ZodEffects<z.ZodString, string, string>;
            title: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
                code: z.ZodString;
                language: z.ZodOptional<z.ZodString>;
            }, "strict", z.ZodTypeAny, {
                code: string;
                language?: string | undefined;
            }, {
                code: string;
                language?: string | undefined;
            }>, "many">>;
            negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
                code: z.ZodString;
                language: z.ZodOptional<z.ZodString>;
            }, "strict", z.ZodTypeAny, {
                code: string;
                language?: string | undefined;
            }, {
                code: string;
                language?: string | undefined;
            }>, "many">>;
            fixable: z.ZodOptional<z.ZodBoolean>;
            cacheable: z.ZodOptional<z.ZodBoolean>;
            level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
            scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
            languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            model: z.ZodOptional<z.ZodString>;
            include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            gritql: z.ZodOptional<z.ZodString>;
            gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
            preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
            processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
            postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
            preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
            processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
            postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
            source: z.ZodOptional<z.ZodString>;
        }, z.ZodTypeAny, "passthrough">[] | undefined;
        overrides?: {
            rules?: Record<string, "error" | "warn" | "off"> | undefined;
            include?: string[] | undefined;
            exclude?: string[] | undefined;
        }[] | undefined;
    }, "ruleDefinitions"> & {
        ruleDefinitions?: string[];
    };
}
declare function sanitizeConfig(config: LinterConfig): Omit<LinterConfig, 'ruleDefinitions'> & {
    ruleDefinitions?: string[];
};

type RuleMetadata<K extends string = string, V = any> = Record<K, V>;
type RuleDefinition<Metadata extends RuleMetadata = RuleMetadata> = {
    name: string;
    title: string;
    description?: string;
    positiveExamples?: RuleExample[];
    negativeExamples?: RuleExample[];
    level: LintRuleLevel;
    scope: LintRuleScope;
    fixable?: boolean;
    cacheable?: boolean;
    languages?: string[];
    tags?: string[];
    eslint?: string[];
    include?: string[];
    exclude?: string[];
    resources?: string[];
    model?: string;
    gritql?: string;
    gritqlNumLinesContext?: number;
    preProcessFile?: RulePreProcessFileFn<Metadata>;
    processFile?: RuleProcessFileFn<Metadata>;
    postProcessFile?: RulePostProcessFileFn<Metadata>;
    preProcessProject?: RulePreProcessProjectFn<Metadata>;
    processProject?: RuleProcessProjectFn<Metadata>;
    postProcessProject?: RulePostProcessProjectFn<Metadata>;
    init?: RuleInitFn<Metadata>;
};
type Rule<Metadata extends RuleMetadata = RuleMetadata> = RuleDefinition<Metadata> & {
    source: string;
    metadata: Metadata;
};
declare const RuleDefinitionExampleSchema: z.ZodObject<{
    code: z.ZodString;
    language: z.ZodOptional<z.ZodString>;
}, "strict", z.ZodTypeAny, {
    code: string;
    language?: string | undefined;
}, {
    code: string;
    language?: string | undefined;
}>;
declare const RuleDefinitionSchema: z.ZodObject<{
    name: z.ZodEffects<z.ZodString, string, string>;
    title: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
        code: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
        code: string;
        language?: string | undefined;
    }, {
        code: string;
        language?: string | undefined;
    }>, "many">>;
    negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
        code: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
        code: string;
        language?: string | undefined;
    }, {
        code: string;
        language?: string | undefined;
    }>, "many">>;
    fixable: z.ZodOptional<z.ZodBoolean>;
    cacheable: z.ZodOptional<z.ZodBoolean>;
    level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
    scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
    languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    model: z.ZodOptional<z.ZodString>;
    include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    gritql: z.ZodOptional<z.ZodString>;
    gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
    preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    source: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    name: z.ZodEffects<z.ZodString, string, string>;
    title: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
        code: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
        code: string;
        language?: string | undefined;
    }, {
        code: string;
        language?: string | undefined;
    }>, "many">>;
    negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
        code: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
        code: string;
        language?: string | undefined;
    }, {
        code: string;
        language?: string | undefined;
    }>, "many">>;
    fixable: z.ZodOptional<z.ZodBoolean>;
    cacheable: z.ZodOptional<z.ZodBoolean>;
    level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
    scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
    languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    model: z.ZodOptional<z.ZodString>;
    include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    gritql: z.ZodOptional<z.ZodString>;
    gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
    preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    source: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    name: z.ZodEffects<z.ZodString, string, string>;
    title: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    positiveExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
        code: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
        code: string;
        language?: string | undefined;
    }, {
        code: string;
        language?: string | undefined;
    }>, "many">>;
    negativeExamples: z.ZodOptional<z.ZodArray<z.ZodObject<{
        code: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, "strict", z.ZodTypeAny, {
        code: string;
        language?: string | undefined;
    }, {
        code: string;
        language?: string | undefined;
    }>, "many">>;
    fixable: z.ZodOptional<z.ZodBoolean>;
    cacheable: z.ZodOptional<z.ZodBoolean>;
    level: z.ZodDefault<z.ZodOptional<z.ZodEnum<["off", "warn", "error"]>>>;
    scope: z.ZodDefault<z.ZodOptional<z.ZodEnum<["file", "project", "repo"]>>>;
    languages: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    eslint: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    resources: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    model: z.ZodOptional<z.ZodString>;
    include: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    exclude: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    gritql: z.ZodOptional<z.ZodString>;
    gritqlNumLinesContext: z.ZodOptional<z.ZodNumber>;
    preProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    processFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    postProcessFile: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    preProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    processProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    postProcessProject: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodAny], null>, z.ZodAny>>;
    source: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>;

type MaybePromise<T> = T | Promise<T>;
type LintRuleLevel = 'error' | 'warn' | 'off';
type LintRuleScope = 'file' | 'project' | 'repo';
type LintRuleErrorConfidence = 'low' | 'medium' | 'high';
type RulePreProcessFileFnParams<Metadata extends RuleMetadata = RuleMetadata> = Readonly<{
    file: SourceFile | PartialSourceFile;
    rule: Rule<Metadata>;
    chatModel: ChatModel;
    cache: LinterCache;
    config: ResolvedLinterConfig;
    retryOptions?: RetryOptions;
    cwd: string;
}>;
type RulePreProcessFileFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RulePreProcessFileFnParams<Metadata>) => MaybePromise<PartialLintResult | void | undefined>;
type RuleProcessFileFnParams<Metadata extends RuleMetadata = RuleMetadata> = Readonly<{
    file: SourceFile | PartialSourceFile;
    rule: Rule<Metadata>;
    lintResult?: LintResult;
    chatModel: ChatModel;
    cache: LinterCache;
    config: ResolvedLinterConfig;
    retryOptions?: RetryOptions;
    cwd: string;
}>;
type RuleProcessFileFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RuleProcessFileFnParams<Metadata>) => MaybePromise<PartialLintResult | undefined>;
type RulePostProcessFileFnParams<Metadata extends RuleMetadata = RuleMetadata> = SetRequired<RuleProcessFileFnParams<Metadata>, 'lintResult'>;
type RulePostProcessFileFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RuleProcessFileFnParams<Metadata>) => MaybePromise<PartialLintResult | undefined>;
type RulePreProcessProjectFnParams<Metadata extends RuleMetadata = RuleMetadata> = Readonly<{
    rule: Rule<Metadata>;
    chatModel: ChatModel;
    cache: LinterCache;
    config: ResolvedLinterConfig;
    retryOptions?: RetryOptions;
    cwd: string;
}>;
type RulePreProcessProjectFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RulePreProcessProjectFnParams<Metadata>) => MaybePromise<PartialLintResult | void | undefined>;
type RuleProcessProjectFnParams<Metadata extends RuleMetadata = RuleMetadata> = Readonly<{
    rule: Rule<Metadata>;
    lintResult?: LintResult;
    chatModel: ChatModel;
    cache: LinterCache;
    config: ResolvedLinterConfig;
    retryOptions?: RetryOptions;
    cwd: string;
}>;
type RuleProcessProjectFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RuleProcessProjectFnParams<Metadata>) => MaybePromise<PartialLintResult | undefined>;
type RulePostProcessProjectFnParams<Metadata extends RuleMetadata = RuleMetadata> = SetRequired<RuleProcessProjectFnParams<Metadata>, 'lintResult'>;
type RulePostProcessProjectFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RuleProcessProjectFnParams<Metadata>) => MaybePromise<PartialLintResult | undefined>;
type RuleInitFnParams<Metadata extends RuleMetadata = RuleMetadata> = Readonly<{
    rule: Rule<Metadata>;
    chatModel: ChatModel;
    cache: LinterCache;
    config: ResolvedLinterConfig;
    retryOptions?: RetryOptions;
    cwd: string;
}>;
type RuleInitFn<Metadata extends RuleMetadata = RuleMetadata> = (opts: RuleInitFnParams<Metadata>) => MaybePromise<void>;
type RuleExample = {
    code: string;
    language?: string;
};
type SourceFile = {
    filePath: string;
    fileName: string;
    fileRelativePath: string;
    content: string;
    language: string;
    ranges?: FileRange[];
    partialContent?: string;
};
type PartialSourceFile = SetRequired<SourceFile, 'partialContent' | 'ranges'>;
interface FileRange {
    start: {
        line: number;
        column?: number;
    };
    end: {
        line: number;
        column?: number;
    };
}
type LintError = {
    ruleName: string;
    filePath: string;
    language?: string;
    model?: string;
    message: string;
    level: LintRuleLevel;
    codeSnippet?: string;
    confidence?: LintRuleErrorConfidence;
    reasoning?: string;
};
type PartialLintError = Simplify<SetOptional<Omit<LintError, 'ruleName' | 'language'>, 'filePath' | 'level' | 'model'>>;
type LintResult = {
    lintErrors: LintError[];
    skipped?: boolean;
    skipReason?: LintSkipReason;
    skipDetail?: string;
    message?: string;
    numModelCalls: number;
    numModelCallsCached: number;
    numPromptTokens: number;
    numCompletionTokens: number;
    numTotalTokens: number;
    totalCost: number;
    startedAtMs: number;
    endedAtMs?: number;
};
type PartialLintResult = Partial<Omit<LintResult, 'lintErrors' | 'startedAtMs' | 'endedAtMs'>> & {
    lintErrors?: PartialLintError[];
};
type LintSkipReason = 'cached' | 'empty' | 'pre-process-file' | 'pre-process-project' | 'grit-pattern' | 'rule-disabled' | 'inline-linter-disabled';
type LintTask = Simplify<{
    scope: LintRuleScope;
    rule: Rule;
    file?: SourceFile | PartialSourceFile;
    config: ResolvedLinterConfig;
    cacheKey: string;
    group: string;
    lintResult?: LintResult;
} & PromiseWithResolvers<unknown> & ({
    scope: 'file';
    file: SourceFile | PartialSourceFile;
} | {
    scope: 'project' | 'repo';
    file: never;
})>;
type ResolvedLintTask = SetRequired<LintTask, 'lintResult'>;
type LintTaskGroup = {
    lintTasks: LintTask[];
    lintResults: LintResult[];
    taskP: Promise<TaskAPI> | undefined;
    innerTask: TaskInnerAPI | undefined;
    init(): Promise<void>;
} & PromiseWithResolvers<unknown>;
type ProgressHandlerFn = (opts: {
    progress: number;
    message: string;
    result: LintResult;
}) => MaybePromise<void>;
type ProgressHandlerInitFn = (opts: {
    numTasks: number;
}) => MaybePromise<void>;
type EvalStats = {
    numFiles: number;
    numRules: number;
    numUnexpectedErrors: number;
    numTruePositives: number;
    numTrueNegatives: number;
    numFalsePositives: number;
    numFalseNegatives: number;
};
type CLIFlags = NonNullable<Command['options']['flags']>;
type RetryOptions = {
    retries: number;
    readonly onFailedAttempt?: (error: FailedAttemptError) => MaybePromise<void>;
};

/**
 * Content-based cache of previous linter results.
 */
declare class LinterCache<TKey extends string = string, TValue extends object = LintResult> {
    noCache: boolean;
    dryRun: boolean;
    cacheDir?: string;
    cacheFile?: string;
    cache?: Record<string, string>;
    protected _exitHookCleanupFn?: () => void;
    constructor({ cacheDir, cacheFileName, noCache, dryRun }: {
        cacheDir?: string;
        cacheFileName?: string;
        noCache?: boolean;
        dryRun?: boolean;
    });
    init(): Promise<this>;
    close(): Promise<void>;
    get(key: TKey): Promise<TValue | undefined>;
    set(key: TKey, value: TValue): Promise<void>;
    flush(): Promise<void>;
}
declare function createCacheKey({ rule, file, config, ...extra }: {
    rule: Rule;
    file?: SourceFile;
    config: LinterConfig;
} & Record<string, unknown>): string;

declare const recommendedConfig: GPTLintConfig;

/**
 * Core linting logic which takes in a single `rule` and a single `file` and
 * uses the `chatModel` LLM to extract rule violations using structured output.
 */
declare function lintFile({ file, rule, lintResult, chatModel, cache, config, cwd, retryOptions, enableGrit }: RuleProcessFileFnParams & {
    enableGrit?: boolean;
}): Promise<LintResult>;
/**
 * If two-pass linting is enabled, then this function is called after the first
 * pass to validate the potential rule violations from the first pass using a
 * smarter model.
 *
 * This pass is aimed at reducing false positives.
 */
declare function validateRuleViolations({ file, rule, lintResult, chatModel, config, retryOptions }: RulePostProcessFileFnParams): Promise<LintResult>;

/**
 * Takes in a list of source files and rules, transforms these into a set
 * of LintTasks, pre-processes each lint task (e.g. caching, validation),
 * processes the non-cached tasks with the LLM-based linting engine, post-
 * processes the results, and then returns an aggregated LintResult.
 */
declare function lintFiles({ files, rules, config, cache, chatModel, cwd, retryOptions, onProgress, onProgressInit }: {
    files: SourceFile[];
    rules: Rule[];
    config: ResolvedLinterConfig;
    cache: LinterCache;
    chatModel: ChatModel;
    cwd?: string;
    retryOptions?: RetryOptions;
    onProgress?: ProgressHandlerFn;
    onProgressInit?: ProgressHandlerInitFn;
}): Promise<LintResult>;

/**
 * Parses a rule definition markdown file and returns the result.
 */
declare function parseRuleFile({ content, filePath }: {
    content: string;
    filePath: string;
}): Promise<Rule>;
declare function parseRuleFilePath(filePath: string, { cwd }?: {
    cwd?: string;
}): Promise<Rule>;
declare function parseRuleFrontmatter(yaml: string | undefined): Partial<RuleDefinition> | undefined;

declare function resolveFiles({ config, cwd }: {
    config: ResolvedLinterConfig;
    cwd?: string;
}): Promise<SourceFile[]>;
declare function resolveEvalFiles({ config, cwd }: {
    config: ResolvedLinterConfig;
    cwd?: string;
}): Promise<SourceFile[]>;
declare function readSourceFiles(filePaths: string[], { concurrency, cwd, minFileSizeBytes, maxFileSizeBytes, maxFileNumLines, maxFileLineLength }?: {
    concurrency?: number;
    cwd?: string;
    minFileSizeBytes?: number;
    maxFileSizeBytes?: number;
    maxFileNumLines?: number;
    maxFileLineLength?: number;
}): Promise<SourceFile[]>;

declare function resolveRules({ config, cwd }: {
    config: ResolvedLinterConfig;
    cwd?: string;
}): Promise<Rule[]>;

/**
 * The core zod schema which is used to parse the LLM's structured output.
 *
 * Note that the order of the keys is empirically important to help the LLM
 * "think" in the right order.
 *
 * Note that `codeSnippetSource`, `reasoning`, `violation`, and `confidence`
 * were all added empirically to increase the LLM's accuracy and to mitigate
 * common forms of false positives.
 */
declare const ruleViolationSchema: z.ZodObject<{
    ruleName: z.ZodOptional<z.ZodString>;
    codeSnippet: z.ZodString;
    codeSnippetSource: z.ZodOptional<z.ZodEnum<["examples", "source", "unknown"]>>;
    reasoning: z.ZodOptional<z.ZodString>;
    violation: z.ZodBoolean;
    confidence: z.ZodEnum<["low", "medium", "high"]>;
}, "strip", z.ZodTypeAny, {
    codeSnippet: string;
    confidence: "low" | "medium" | "high";
    violation: boolean;
    ruleName?: string | undefined;
    reasoning?: string | undefined;
    codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
}, {
    codeSnippet: string;
    confidence: "low" | "medium" | "high";
    violation: boolean;
    ruleName?: string | undefined;
    reasoning?: string | undefined;
    codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
}>;
type RuleViolation = z.infer<typeof ruleViolationSchema>;
declare const ruleViolationsOutputSchema: z.ZodArray<z.ZodObject<{
    ruleName: z.ZodOptional<z.ZodString>;
    codeSnippet: z.ZodString;
    codeSnippetSource: z.ZodOptional<z.ZodEnum<["examples", "source", "unknown"]>>;
    reasoning: z.ZodOptional<z.ZodString>;
    violation: z.ZodBoolean;
    confidence: z.ZodEnum<["low", "medium", "high"]>;
}, "strip", z.ZodTypeAny, {
    codeSnippet: string;
    confidence: "low" | "medium" | "high";
    violation: boolean;
    ruleName?: string | undefined;
    reasoning?: string | undefined;
    codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
}, {
    codeSnippet: string;
    confidence: "low" | "medium" | "high";
    violation: boolean;
    ruleName?: string | undefined;
    reasoning?: string | undefined;
    codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
}>, "many">;
type RuleViolationsOutput = z.infer<typeof ruleViolationsOutputSchema>;
declare const ruleViolationsValidatedOutputSchema: z.ZodObject<{
    ruleViolations: z.ZodArray<z.ZodObject<{
        ruleName: z.ZodOptional<z.ZodString>;
        codeSnippet: z.ZodString;
        codeSnippetSource: z.ZodOptional<z.ZodEnum<["examples", "source", "unknown"]>>;
        reasoning: z.ZodOptional<z.ZodString>;
        violation: z.ZodBoolean;
        confidence: z.ZodEnum<["low", "medium", "high"]>;
    }, "strip", z.ZodTypeAny, {
        codeSnippet: string;
        confidence: "low" | "medium" | "high";
        violation: boolean;
        ruleName?: string | undefined;
        reasoning?: string | undefined;
        codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
    }, {
        codeSnippet: string;
        confidence: "low" | "medium" | "high";
        violation: boolean;
        ruleName?: string | undefined;
        reasoning?: string | undefined;
        codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    ruleViolations: {
        codeSnippet: string;
        confidence: "low" | "medium" | "high";
        violation: boolean;
        ruleName?: string | undefined;
        reasoning?: string | undefined;
        codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
    }[];
}, {
    ruleViolations: {
        codeSnippet: string;
        confidence: "low" | "medium" | "high";
        violation: boolean;
        ruleName?: string | undefined;
        reasoning?: string | undefined;
        codeSnippetSource?: "source" | "unknown" | "examples" | undefined;
    }[];
}>;
type RuleViolationsValidatedOutput = z.infer<typeof ruleViolationsValidatedOutputSchema>;
declare function parseRuleViolationsFromJSONModelResponse(response: string): RuleViolation[];
/**
 * Attempts to parse an array of `RuleViolation` objects from a JSON code block
 * in the given markdown response.
 *
 * Will throw a `RetryableError` if the response is invalid with an error
 * message that the LLM can use to retry the request.
 */
declare function parseRuleViolationsFromMarkdownModelResponse(response: string, { numExpectedMarkdownHeadings }?: {
    numExpectedMarkdownHeadings?: number;
}): RuleViolation[];
declare function stringifyRuleViolationSchemaForModel(rule: Rule, file: SourceFile): string;
declare function stringifyExampleRuleViolationsObjectOutputForModel(rule: Rule): string;
declare function stringifyExampleRuleViolationsArrayOutputForModel(rule: Rule): string;
declare function stringifyRuleViolationForModel(ruleViolations: Partial<RuleViolation>[]): string;
declare function isRuleViolationLikelyFalsePositive({ ruleViolation, rule, file }: {
    ruleViolation: RuleViolation;
    rule: Pick<Rule, 'name' | 'negativeExamples'>;
    file: Pick<SourceFile, 'fileRelativePath' | 'content' | 'partialContent'>;
}): boolean;
declare function isRuleViolationLikelyFalsePositiveFromExamples({ ruleViolation, rule, file }: {
    ruleViolation: RuleViolation;
    rule: Pick<Rule, 'name' | 'negativeExamples'>;
    file: Pick<SourceFile, 'fileRelativePath' | 'content' | 'partialContent'>;
}): boolean;

/**
 * From `inputObj`, create a new object that does not include `keys`.
 *
 * @example
 * ```js
 * omit({ a: 1, b: 2, c: 3 }, 'a', 'c') // { b: 2 }
 * ```
 */
declare const omit: <T extends Record<any, unknown>, K extends keyof T = keyof T>(inputObj: T, ...keys: K[]) => Omit<T, K>;
/**
 * From `inputObj`, create a new object that only includes `keys`.
 *
 * @example
 * ```js
 * pick({ a: 1, b: 2, c: 3 }, 'a', 'c') // { a: 1, c: 3 }
 * ```
 */
declare const pick: <T extends Record<any, unknown>, K extends keyof T = keyof T>(inputObj: T, ...keys: K[]) => Pick<T, K>;
declare function pruneUndefined<T extends Record<string, any>>(obj: T): NonNullable<T>;
declare function trimMessage(message: string | undefined, { maxLength }?: {
    maxLength?: number;
}): string;
declare function createEvalStats(): EvalStats;
declare function mergeEvalStats(evalStatsA: EvalStats, evalStatsB: EvalStats): EvalStats;
declare function inferBestPossibleCodeFileExtension(lang?: string | null, { fallbacks }?: {
    fallbacks?: string[];
}): string | undefined;
declare function getEnv(name: string, defaultValue?: string): string | undefined;
declare function logDebugConfig({ files, rules, config }: {
    files?: SourceFile[];
    rules?: Rule[];
    config: ResolvedLinterConfig;
}): void;
declare function logLintResultStats({ lintResult, config, prefix }: {
    lintResult: LintResult;
    config: ResolvedLinterConfig;
    prefix?: string;
}): void;
declare function logEvalStats({ evalStats }: {
    evalStats: EvalStats;
}): {
    precision: number;
    recall: number;
    f1Score: number;
};
/** Polyfill for `Promise.withResolvers()` */
declare function createPromiseWithResolvers<T = unknown>(): PromiseWithResolvers<T>;
/**
 * Wraps [globby](https://github.com/sindresorhus/globby) to correctly handle
 * absolute file patterns that exist outside of the `cwd`.
 */
declare function resolveGlobFilePatterns(patternOrPatterns: string | readonly string[], options?: Options): Promise<string[]>;
declare function dirname(meta?: ImportMeta): string;
declare function fileMatchesIncludeExclude(file: SourceFile, { include, exclude }: {
    include?: string[];
    exclude?: string[];
}): boolean;
declare function validateLinterInputs({ config, files, rules }: {
    config: ResolvedLinterConfig;
    files?: SourceFile[];
    rules?: Rule[];
}): boolean;

export { type CLIFlags, type EvalStats, type FileRange, type FullyResolvedLinterConfig, type GPTLintConfig, type LLMOptions, LLMOptionsSchema, type LintError, type LintResult, type LintRuleErrorConfidence, type LintRuleLevel, type LintRuleScope, type LintSkipReason, type LintTask, type LintTaskGroup, type LinterConfig, type LinterConfigOverride, LinterConfigOverrideSchema, type LinterConfigOverrides, LinterConfigOverridesSchema, type LinterConfigRuleSetting, LinterConfigRuleSettingSchema, type LinterConfigRuleSettings, LinterConfigRuleSettingsSchema, LinterConfigSchema, type LinterOptions, LinterOptionsSchema, type MaybePromise, type PartialLintError, type PartialLintResult, type PartialSourceFile, type ProgressHandlerFn, type ProgressHandlerInitFn, type ResolvedLLMOptions, type ResolvedLintTask, ResolvedLinterConfig, type ResolvedLinterOptions, type RetryOptions, type Rule, type RuleDefinition, RuleDefinitionExampleSchema, RuleDefinitionSchema, type RuleExample, type RuleInitFn, type RuleInitFnParams, type RuleMetadata, type RulePostProcessFileFn, type RulePostProcessFileFnParams, type RulePostProcessProjectFn, type RulePostProcessProjectFnParams, type RulePreProcessFileFn, type RulePreProcessFileFnParams, type RulePreProcessProjectFn, type RulePreProcessProjectFnParams, type RuleProcessFileFn, type RuleProcessFileFnParams, type RuleProcessProjectFn, type RuleProcessProjectFnParams, type RuleViolation, type RuleViolationsOutput, type RuleViolationsValidatedOutput, type SourceFile, createCacheKey, createEvalStats, createPromiseWithResolvers, defaultCacheDir, defaultLLMOptions, defaultLinterConfig, defaultLinterOptions, dirname, fileMatchesIncludeExclude, getEnv, inferBestPossibleCodeFileExtension, isRuleViolationLikelyFalsePositive, isRuleViolationLikelyFalsePositiveFromExamples, isValidModel, lintFile, lintFiles, logDebugConfig, logEvalStats, logLintResultStats, mergeEvalStats, mergeLinterConfigRuleSettings, mergeLinterConfigs, mergeLinterConfigsOverride, omit, parseLinterConfig, parseRuleFile, parseRuleFilePath, parseRuleFrontmatter, parseRuleViolationsFromJSONModelResponse, parseRuleViolationsFromMarkdownModelResponse, pick, pruneUndefined, readSourceFiles, recommendedConfig, resolveEvalFiles, resolveFiles, resolveGlobFilePatterns, resolveLinterConfig, resolveRules, ruleViolationSchema, ruleViolationsOutputSchema, ruleViolationsValidatedOutputSchema, sanitizeConfig, stringifyExampleRuleViolationsArrayOutputForModel, stringifyExampleRuleViolationsObjectOutputForModel, stringifyRuleViolationForModel, stringifyRuleViolationSchemaForModel, trimMessage, validateLinterInputs, validateRuleViolations };
