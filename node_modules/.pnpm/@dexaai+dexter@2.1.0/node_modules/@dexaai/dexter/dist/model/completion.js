import { calculateCost } from './utils/calculate-cost.js';
import { createOpenAIClient } from './clients/openai.js';
import { AbstractModel } from './model.js';
import { deepMerge, mergeEvents } from '../index.js';
export class CompletionModel extends AbstractModel {
    modelType = 'completion';
    modelProvider = 'openai';
    constructor(args) {
        let { client, params, ...rest } = args ?? {};
        // Add a default client if none is provided
        client = client ?? createOpenAIClient();
        // Set default model if no params are provided
        params = params ?? { model: 'gpt-3.5-turbo-instruct' };
        super({ client, params, ...rest });
    }
    async runModel({ requestOpts, ...params }, context) {
        const start = Date.now();
        // Make the OpenAI API request
        const response = await this.client.createCompletions(params, requestOpts);
        await Promise.allSettled(this.events?.onApiResponse?.map((event) => Promise.resolve(event({
            timestamp: new Date().toISOString(),
            modelType: this.modelType,
            modelProvider: this.modelProvider,
            params,
            response,
            latency: Date.now() - start,
            context,
        }))) ?? []);
        const modelResponse = {
            ...response,
            completion: response.choices[0].text,
            cached: false,
            cost: calculateCost({ model: params.model, tokens: response.usage }),
        };
        return modelResponse;
    }
    /** Clone the model and merge/override the given properties. */
    extend(args) {
        return new CompletionModel({
            cacheKey: this.cacheKey,
            cache: this.cache,
            client: this.client,
            debug: this.debug,
            ...args,
            context: deepMerge(this.context, args?.context),
            params: deepMerge(this.params, args?.params),
            events: mergeEvents(this.events, args?.events),
        });
    }
}
//# sourceMappingURL=completion.js.map