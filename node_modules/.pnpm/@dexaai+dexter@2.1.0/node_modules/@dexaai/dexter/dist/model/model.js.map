{"version":3,"file":"model.js","sourceRoot":"","sources":["../../src/model/model.ts"],"names":[],"mappings":"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","sourcesContent":["import type { PartialDeep } from 'type-fest';\nimport { createTokenizer } from './utils/tokenizer.js';\nimport type { Model } from './types.js';\nimport { deepMerge, type Prettify } from '../utils/helpers.js';\nimport {\n  type CacheKey,\n  type CacheStorage,\n  defaultCacheKey,\n} from '../utils/cache.js';\n\nexport interface ModelArgs<\n  MClient extends Model.Base.Client,\n  MConfig extends Model.Base.Config,\n  MRun extends Model.Base.Run,\n  MResponse extends Model.Base.Response,\n  Ctx extends Model.Ctx,\n> {\n  /**\n   * A function that returns a cache key for the given params.\n   *\n   * A simple example would be: `(params) => JSON.stringify(params)`\n   *\n   * The default `cacheKey` function uses [hash-object](https://github.com/sindresorhus/hash-object) to create a stable sha256 hash of the params.\n   */\n  cacheKey?: CacheKey<MRun & MConfig, string>;\n  /**\n   * Enables caching for model responses. Must implement `.get(key)` and `.set(key, value)`, both of which can be either sync or async.\n   *\n   * Some examples include: `new Map()`, [quick-lru](https://github.com/sindresorhus/quick-lru), or any [keyv adaptor](https://github.com/jaredwray/keyv).\n   */\n  cache?: CacheStorage<string, MResponse>;\n  client: MClient;\n  context?: Ctx;\n  params: MConfig & Partial<MRun>;\n  events?: Model.Events<MRun & MConfig, MResponse, Ctx>;\n  /** Whether or not to add default `console.log` event handlers */\n  debug?: boolean;\n}\n\nexport type PartialModelArgs<\n  MClient extends Model.Base.Client,\n  MConfig extends Model.Base.Config,\n  MRun extends Model.Base.Run,\n  MResponse extends Model.Base.Response,\n  CustomCtx extends Model.Ctx,\n> = Prettify<\n  PartialDeep<\n    Pick<\n      ModelArgs<MClient, MConfig, MRun, MResponse, Partial<CustomCtx>>,\n      'params'\n    >\n  > &\n    Partial<\n      Omit<\n        ModelArgs<MClient, MConfig, MRun, MResponse, Partial<CustomCtx>>,\n        'params'\n      >\n    >\n>;\n\nexport abstract class AbstractModel<\n  MClient extends Model.Base.Client,\n  MConfig extends Model.Base.Config,\n  MRun extends Model.Base.Run,\n  MResponse extends Model.Base.Response,\n  AResponse extends any = any,\n  CustomCtx extends Model.Ctx = Model.Ctx,\n> {\n  /** This is used to implement specific model calls */\n  protected abstract runModel(\n    params: Prettify<MRun & MConfig>,\n    context: CustomCtx\n  ): Promise<MResponse>;\n\n  /** Clones the model, optionally modifying its config */\n  abstract extend<\n    Args extends PartialModelArgs<MClient, MConfig, MRun, MResponse, CustomCtx>,\n  >(args?: Args): this;\n\n  public abstract readonly modelType: Model.Type;\n  public abstract readonly modelProvider: Model.Provider;\n\n  protected readonly cacheKey: CacheKey<MRun & MConfig, string>;\n  protected readonly cache?: CacheStorage<string, MResponse>;\n  public readonly client: MClient;\n  public readonly context: CustomCtx;\n  public readonly debug: boolean;\n  public readonly params: MConfig & Partial<MRun>;\n  public readonly events: Model.Events<\n    MRun & MConfig,\n    MResponse,\n    CustomCtx,\n    AResponse\n  >;\n  public readonly tokenizer: Model.ITokenizer;\n\n  constructor(args: ModelArgs<MClient, MConfig, MRun, MResponse, CustomCtx>) {\n    this.cacheKey = args.cacheKey ?? defaultCacheKey;\n    this.cache = args.cache;\n    this.client = args.client;\n    this.context = args.context ?? ({} as CustomCtx);\n    this.debug = args.debug ?? false;\n    this.params = args.params;\n    this.events = args.events || {};\n    this.tokenizer = createTokenizer(args.params.model);\n  }\n\n  async run(\n    params: Prettify<MRun & Partial<MConfig>>,\n    context?: CustomCtx\n  ): Promise<MResponse> {\n    const start = Date.now();\n\n    const mergedContext = deepMerge(this.context, context);\n    const mergedParams = deepMerge(this.params, params);\n\n    // Handle signal separately since it's a instance of AbortSignal\n    if (params.requestOpts?.signal && mergedParams.requestOpts) {\n      mergedParams.requestOpts.signal = params.requestOpts.signal;\n    }\n\n    await Promise.allSettled(\n      this.events.onStart?.map((event) =>\n        Promise.resolve(\n          event({\n            timestamp: new Date().toISOString(),\n            modelType: this.modelType,\n            modelProvider: this.modelProvider,\n            params: mergedParams,\n            context: mergedContext,\n          })\n        )\n      ) ?? []\n    );\n\n    const cacheKey = await this.cacheKey(mergedParams);\n\n    try {\n      // Check the cache\n      const cachedResponse =\n        this.cache && (await Promise.resolve(this.cache.get(cacheKey)));\n      if (cachedResponse) {\n        const response: MResponse = {\n          ...cachedResponse,\n          cached: true,\n          cost: 0,\n          latency: Date.now() - start,\n        };\n        await Promise.allSettled(\n          this.events.onComplete?.map((event) =>\n            Promise.resolve(\n              event({\n                timestamp: new Date().toISOString(),\n                modelType: this.modelType,\n                modelProvider: this.modelProvider,\n                params: mergedParams,\n                response,\n                context: mergedContext,\n                cached: true,\n              })\n            )\n          ) ?? []\n        );\n        return response;\n      }\n\n      // Run the model (e.g. make the API request)\n      const response = await this.runModel(mergedParams, mergedContext);\n\n      await Promise.allSettled(\n        this.events.onComplete?.map((event) =>\n          Promise.resolve(\n            event({\n              timestamp: new Date().toISOString(),\n              modelType: this.modelType,\n              modelProvider: this.modelProvider,\n              params: mergedParams,\n              response,\n              context: mergedContext,\n              cached: false,\n            })\n          )\n        ) ?? []\n      );\n\n      // Update the cache\n      await Promise.resolve(this.cache?.set(cacheKey, response));\n\n      return response;\n    } catch (error) {\n      await Promise.allSettled(\n        this.events?.onError?.map((event) =>\n          Promise.resolve(\n            event({\n              timestamp: new Date().toISOString(),\n              modelType: this.modelType,\n              modelProvider: this.modelProvider,\n              params: mergedParams,\n              error,\n              context: mergedContext,\n            })\n          )\n        ) ?? []\n      );\n      throw error;\n    }\n  }\n}\n"]}