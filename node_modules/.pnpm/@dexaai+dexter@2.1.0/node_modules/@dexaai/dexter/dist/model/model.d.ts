import type { PartialDeep } from 'type-fest';
import type { Model } from './types.js';
import { type Prettify } from '../utils/helpers.js';
import { type CacheKey, type CacheStorage } from '../utils/cache.js';
export interface ModelArgs<MClient extends Model.Base.Client, MConfig extends Model.Base.Config, MRun extends Model.Base.Run, MResponse extends Model.Base.Response, Ctx extends Model.Ctx> {
    /**
     * A function that returns a cache key for the given params.
     *
     * A simple example would be: `(params) => JSON.stringify(params)`
     *
     * The default `cacheKey` function uses [hash-object](https://github.com/sindresorhus/hash-object) to create a stable sha256 hash of the params.
     */
    cacheKey?: CacheKey<MRun & MConfig, string>;
    /**
     * Enables caching for model responses. Must implement `.get(key)` and `.set(key, value)`, both of which can be either sync or async.
     *
     * Some examples include: `new Map()`, [quick-lru](https://github.com/sindresorhus/quick-lru), or any [keyv adaptor](https://github.com/jaredwray/keyv).
     */
    cache?: CacheStorage<string, MResponse>;
    client: MClient;
    context?: Ctx;
    params: MConfig & Partial<MRun>;
    events?: Model.Events<MRun & MConfig, MResponse, Ctx>;
    /** Whether or not to add default `console.log` event handlers */
    debug?: boolean;
}
export type PartialModelArgs<MClient extends Model.Base.Client, MConfig extends Model.Base.Config, MRun extends Model.Base.Run, MResponse extends Model.Base.Response, CustomCtx extends Model.Ctx> = Prettify<PartialDeep<Pick<ModelArgs<MClient, MConfig, MRun, MResponse, Partial<CustomCtx>>, 'params'>> & Partial<Omit<ModelArgs<MClient, MConfig, MRun, MResponse, Partial<CustomCtx>>, 'params'>>>;
export declare abstract class AbstractModel<MClient extends Model.Base.Client, MConfig extends Model.Base.Config, MRun extends Model.Base.Run, MResponse extends Model.Base.Response, AResponse extends any = any, CustomCtx extends Model.Ctx = Model.Ctx> {
    /** This is used to implement specific model calls */
    protected abstract runModel(params: Prettify<MRun & MConfig>, context: CustomCtx): Promise<MResponse>;
    /** Clones the model, optionally modifying its config */
    abstract extend<Args extends PartialModelArgs<MClient, MConfig, MRun, MResponse, CustomCtx>>(args?: Args): this;
    abstract readonly modelType: Model.Type;
    abstract readonly modelProvider: Model.Provider;
    protected readonly cacheKey: CacheKey<MRun & MConfig, string>;
    protected readonly cache?: CacheStorage<string, MResponse>;
    readonly client: MClient;
    readonly context: CustomCtx;
    readonly debug: boolean;
    readonly params: MConfig & Partial<MRun>;
    readonly events: Model.Events<MRun & MConfig, MResponse, CustomCtx, AResponse>;
    readonly tokenizer: Model.ITokenizer;
    constructor(args: ModelArgs<MClient, MConfig, MRun, MResponse, CustomCtx>);
    run(params: Prettify<MRun & Partial<MConfig>>, context?: CustomCtx): Promise<MResponse>;
}
