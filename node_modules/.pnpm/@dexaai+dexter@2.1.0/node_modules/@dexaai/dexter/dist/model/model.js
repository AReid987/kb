import { createTokenizer } from './utils/tokenizer.js';
import { deepMerge } from '../utils/helpers.js';
import { defaultCacheKey, } from '../utils/cache.js';
export class AbstractModel {
    cacheKey;
    cache;
    client;
    context;
    debug;
    params;
    events;
    tokenizer;
    constructor(args) {
        this.cacheKey = args.cacheKey ?? defaultCacheKey;
        this.cache = args.cache;
        this.client = args.client;
        this.context = args.context ?? {};
        this.debug = args.debug ?? false;
        this.params = args.params;
        this.events = args.events || {};
        this.tokenizer = createTokenizer(args.params.model);
    }
    async run(params, context) {
        const start = Date.now();
        const mergedContext = deepMerge(this.context, context);
        const mergedParams = deepMerge(this.params, params);
        // Handle signal separately since it's a instance of AbortSignal
        if (params.requestOpts?.signal && mergedParams.requestOpts) {
            mergedParams.requestOpts.signal = params.requestOpts.signal;
        }
        await Promise.allSettled(this.events.onStart?.map((event) => Promise.resolve(event({
            timestamp: new Date().toISOString(),
            modelType: this.modelType,
            modelProvider: this.modelProvider,
            params: mergedParams,
            context: mergedContext,
        }))) ?? []);
        const cacheKey = await this.cacheKey(mergedParams);
        try {
            // Check the cache
            const cachedResponse = this.cache && (await Promise.resolve(this.cache.get(cacheKey)));
            if (cachedResponse) {
                const response = {
                    ...cachedResponse,
                    cached: true,
                    cost: 0,
                    latency: Date.now() - start,
                };
                await Promise.allSettled(this.events.onComplete?.map((event) => Promise.resolve(event({
                    timestamp: new Date().toISOString(),
                    modelType: this.modelType,
                    modelProvider: this.modelProvider,
                    params: mergedParams,
                    response,
                    context: mergedContext,
                    cached: true,
                }))) ?? []);
                return response;
            }
            // Run the model (e.g. make the API request)
            const response = await this.runModel(mergedParams, mergedContext);
            await Promise.allSettled(this.events.onComplete?.map((event) => Promise.resolve(event({
                timestamp: new Date().toISOString(),
                modelType: this.modelType,
                modelProvider: this.modelProvider,
                params: mergedParams,
                response,
                context: mergedContext,
                cached: false,
            }))) ?? []);
            // Update the cache
            await Promise.resolve(this.cache?.set(cacheKey, response));
            return response;
        }
        catch (error) {
            await Promise.allSettled(this.events?.onError?.map((event) => Promise.resolve(event({
                timestamp: new Date().toISOString(),
                modelType: this.modelType,
                modelProvider: this.modelProvider,
                params: mergedParams,
                error,
                context: mergedContext,
            }))) ?? []);
            throw error;
        }
    }
}
//# sourceMappingURL=model.js.map