import type { Datastore } from './types.js';
import { type CacheKey, type CacheStorage } from '../utils/cache.js';
export declare abstract class AbstractDatastore<DocMeta extends Datastore.BaseMeta, Filter extends Datastore.BaseFilter<DocMeta>> {
    protected abstract runQuery(query: Datastore.Query<DocMeta, Filter>, context?: Datastore.Ctx): Promise<Datastore.QueryResult<DocMeta>>;
    abstract upsert(docs: Datastore.Doc<DocMeta>[], context?: Datastore.Ctx): Promise<void>;
    abstract delete(docIds: string[]): Promise<void>;
    abstract deleteAll(): Promise<void>;
    /** Clones the datastore, optionally modifying it's config */
    abstract extend<Args extends Datastore.Opts<DocMeta, Filter>>(args?: Partial<Args>): this;
    abstract readonly datastoreType: Datastore.Type;
    abstract readonly datastoreProvider: Datastore.Provider;
    protected readonly cacheKey: CacheKey<Datastore.Query<DocMeta, Filter>, string>;
    protected readonly cache?: CacheStorage<string, Datastore.QueryResult<DocMeta>>;
    readonly contentKey: keyof DocMeta;
    readonly embeddingModel: any;
    readonly namespace?: string;
    readonly events: Datastore.Events<DocMeta, Filter>;
    readonly context: Datastore.Ctx;
    readonly debug: boolean;
    constructor(args: Datastore.Opts<DocMeta, Filter>);
    query(query: Datastore.Query<DocMeta, Filter>, context?: Datastore.Ctx): Promise<Datastore.QueryResult<DocMeta>>;
}
