import { defaultCacheKey, } from '../utils/cache.js';
import { mergeEvents } from '../utils/helpers.js';
export class AbstractDatastore {
    cacheKey;
    cache;
    contentKey;
    embeddingModel;
    namespace;
    events;
    context;
    debug;
    constructor(args) {
        this.namespace = args.namespace;
        this.contentKey = args.contentKey;
        this.embeddingModel = args.embeddingModel;
        this.cacheKey = args.cacheKey ?? defaultCacheKey;
        this.cache = args.cache;
        this.context = args.context ?? {};
        this.debug = args.debug ?? false;
        this.events = mergeEvents(args.events, args.debug
            ? {
                onQueryStart: [console.debug],
                onQueryComplete: [console.debug],
                onError: [console.error],
            }
            : {});
    }
    async query(query, context) {
        const start = Date.now();
        const mergedContext = { ...this.context, ...context };
        await Promise.allSettled(this.events?.onQueryStart?.map((event) => Promise.resolve(event({
            timestamp: new Date().toISOString(),
            datastoreType: this.datastoreType,
            datastoreProvider: this.datastoreProvider,
            query,
            context: mergedContext,
        }))) ?? []);
        const cacheKey = await this.cacheKey(query);
        // Return cached response if available
        const cached = await Promise.resolve(this.cache?.get(cacheKey));
        if (cached) {
            await Promise.allSettled(this.events?.onQueryComplete?.map((event) => Promise.resolve(event({
                timestamp: new Date().toISOString(),
                datastoreType: this.datastoreType,
                datastoreProvider: this.datastoreProvider,
                query,
                response: cached,
                cached: true,
                context: mergedContext,
                latency: Date.now() - start,
            }))) ?? []);
            return {
                ...cached,
                cached: true,
            };
        }
        try {
            // Run the query
            const response = await this.runQuery(query, context);
            await Promise.allSettled(this.events?.onQueryComplete?.map((event) => Promise.resolve(event({
                timestamp: new Date().toISOString(),
                datastoreType: this.datastoreType,
                datastoreProvider: this.datastoreProvider,
                query,
                response,
                cached: false,
                context: mergedContext,
                latency: Date.now() - start,
            }))) ?? []);
            // Update the cache
            await Promise.resolve(this.cache?.set(cacheKey, response));
            return {
                ...response,
                cached: false,
            };
        }
        catch (error) {
            await Promise.allSettled(this.events?.onError?.map((event) => Promise.resolve(event({
                timestamp: new Date().toISOString(),
                datastoreType: this.datastoreType,
                datastoreProvider: this.datastoreProvider,
                error,
                context: mergedContext,
            }))) ?? []);
            throw error;
        }
    }
}
//# sourceMappingURL=datastore.js.map