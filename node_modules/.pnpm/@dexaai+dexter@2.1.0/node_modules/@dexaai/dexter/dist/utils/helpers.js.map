{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../src/utils/helpers.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,IAAI,aAAa,EAAE,MAAM,oBAAoB,CAAC;AAMhE,MAAM,CAAC,MAAM,aAAa,GAAc,aAAa,EAAE,CAAC;AAExD,MAAM,mBAAmB,GAAc,aAAa,CAAC;IACnD,iFAAiF;IACjF,UAAU,EAAE,GAAG,EAAE,CAAC,CAAC,CAAQ,EAAE,CAAQ,EAAE,EAAE,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;CACrE,CAAC,CAAC;AAEH,kFAAkF;AAClF,MAAM,UAAU,SAAS,CAGvB,EAAO,EAAE,EAAO;IAChB,OAAO,aAAa,CAClB,EAAE,IAAK,EAAS,EAChB,EAAE,IAAK,EAAS,CACC,CAAC;AACtB,CAAC;AAED,iFAAiF;AACjF,uDAAuD;AACvD,MAAM,UAAU,WAAW,CAGzB,EAAO,EAAE,EAAO;IAChB,OAAO,mBAAmB,CACxB,EAAE,IAAK,EAAS,EAChB,EAAE,IAAK,EAAS,CACC,CAAC;AACtB,CAAC;AAED,8EAA8E;AAC9E,SAAS,YAAY,CAAC,KAAY;IAChC,MAAM,IAAI,GAAG,IAAI,GAAG,EAAE,CAAC;IACvB,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;QAC5B,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YACpB,OAAO,KAAK,CAAC;QACf,CAAC;QACD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAChB,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,IAAI,GAAG,CAClB,GAAM,EACN,GAAG,IAAS,EACA,EAAE,CACd,MAAM,CAAC,WAAW,CAChB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAQ,CAAC,CAAC,CACvD,CAAC;AAEX;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,IAAI,GAAG,CAClB,GAAM,EACN,GAAG,IAAS,EACA,EAAE,CACd,MAAM,CAAC,WAAW,CAChB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAQ,CAAC,CAAC,CACtD,CAAC","sourcesContent":["import { deepmerge as deepmergeInit } from '@fastify/deepmerge';\n\n/** Improve preview of union types in autocomplete. */\nexport type Prettify<T> = { [K in keyof T]: T[K] } & {};\n\ntype DeepMerge = ReturnType<typeof deepmergeInit>;\nexport const deepMergeImpl: DeepMerge = deepmergeInit();\n\nconst deepMergeEventsImpl: DeepMerge = deepmergeInit({\n  // Note: this is not using a recursive deep merge since it isn't used for events.\n  mergeArray: () => (a: any[], b: any[]) => stableDedupe([...a, ...b]),\n});\n\n// Slightly custom deepMerge which handles `undefined` arguments as empty objects.\nexport function deepMerge<\n  T1 extends object | undefined | null,\n  T2 extends object | undefined | null,\n>(t1?: T1, t2?: T2): T1 & T2 {\n  return deepMergeImpl<T1, T2>(\n    t1 ?? ({} as T1),\n    t2 ?? ({} as T2)\n  ) as unknown as any;\n}\n\n// Slightly custom deepMerge which handles `undefined` arguments as empty objects\n// and ensures that we remove duplicate event handlers.\nexport function mergeEvents<\n  T1 extends object | undefined,\n  T2 extends object | undefined,\n>(t1?: T1, t2?: T2): T1 & T2 {\n  return deepMergeEventsImpl<T1, T2>(\n    t1 ?? ({} as T1),\n    t2 ?? ({} as T2)\n  ) as unknown as any;\n}\n\n/** Dedupes the given array maintaining a stable order in the output array. */\nfunction stableDedupe(input: any[]) {\n  const seen = new Set();\n  return input.filter((value) => {\n    if (seen.has(value)) {\n      return false;\n    }\n    seen.add(value);\n    return true;\n  });\n}\n\n/**\n * From `obj`, create a new object that does not include `keys`.\n *\n * @example\n * ```\n * omit({ a: 1, b: 2, c: 3 }, 'a', 'c') // { b: 2 }\n * ```\n */\nexport const omit = <T extends Record<any, unknown>, K extends keyof T>(\n  obj: T,\n  ...keys: K[]\n): Omit<T, K> =>\n  Object.fromEntries(\n    Object.entries(obj).filter(([k]) => !keys.includes(k as any))\n  ) as any;\n\n/**\n * From `obj`, create a new object that only includes `keys`.\n *\n * @example\n * ```\n * pick({ a: 1, b: 2, c: 3 }, 'a', 'c') // { a: 1, c: 3 }\n * ```\n */\nexport const pick = <T extends Record<any, unknown>, K extends keyof T>(\n  obj: T,\n  ...keys: K[]\n): Pick<T, K> =>\n  Object.fromEntries(\n    Object.entries(obj).filter(([k]) => keys.includes(k as any))\n  ) as any;\n"]}